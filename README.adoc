:ext-relative: {outfilesuffix}

image:https://travis-ci.org/ralfbiedert/ffsvm-rust.svg?branch=master["Build Status", link="https://travis-ci.org/ralfbiedert/ffsvm-rust"]
image:https://img.shields.io/badge/license-MIT-blue.svg["License", link="LICENSE"]
image:https://img.shields.io/badge/SIMD-faster-orange.svg["SIMD enabled", link="https://github.com/AdamNiederer/faster"]
image:https://img.shields.io/badge/threading-rayon-orange.svg["SIMD enabled", link="https://github.com/rayon-rs/rayon"]
image:https://img.shields.io/badge/fancy%20badges-all%20of%20them-ff69b4.svg["SIMD enabled", link="https://shields.io"]


= In One Sentence

You trained a non-sparse RBF-C-SVM using https://github.com/cjlin1/libsvm[libSVM], now you want the highest possible performance during (real-time) classification, like games or VR.



= Highlights

* can load trained https://github.com/cjlin1/libsvm[libSVM] models (currently binary RBF-CSVM without sparse attributes)
* optimized for SIMD (using https://github.com/AdamNiederer/faster[Faster]) and threading (using https://github.com/rayon-rs/rayon[Rayon])
* allocation-free during classification



= Principal Usage

Train with https://github.com/cjlin1/libsvm[libSVM] (e.g., using the tool `svm-train`), then classify with `ffsvm-rust`.

From Rust:

[source,rust]
----

// Get your libSVM model string from wherever and parse it.
let model_str: &str = include_str!("model.libsvm");
let model = ModelFile::try_from(model_str).unwrap();

// Produce actual SVM from raw model, and a problem
let csvm = RbfCSVM::try_from(&model).unwrap();
let mut problem = Problem::from(&csvm);

// Set the features of this problem we want to classify.
problem.features = vec![ 0.3093766, 0.0, 0.0, 0.0, 0.0, 0.1764706, 0.1137485 ];

// (We also have methods to classify multiple in parallel w. Rayon ...)
csvm.predict_value(&mut problem);

// Results should match libSVM
assert_eq!(0, problem.label);
----

From C / FFI:

[source,c]
----


// Create a context (which holds our SVM)
ffsvm_context_create(&context);

// Set how many problems we will classify at most in parallel
ffsvm_set_max_problems(context, 100);

// Load the model from a string (model is char[])
ffsvm_model_load(context, model);

// Get the labels of the SVM model (useful for predicting probabilities that don't return labels)
ffsvm_model_get_labels(context, labels_ptr, labels_len);

// Classify (features is float[], problem_labels is int[])
ffsvm_predict_values(context, features, total_features, problem_labels, num_problems);

// Classify and predict probabilities.
ffsvm_predict_probabilities(context, features, total_features, probabilities_ptr, probabilities_len);

// Clean up once done
ffsvm_context_destroy(&context);

----

link:tests/ffi.py[Also see the Python FFI example.]


= Status

**December 16, 2017**: We're in **PRE-ALPHA**. It will probably not even work on your machine.


= Performance History

image::https://i.imgur.com/yQWstOV.png[]


link:docs/performance{ext-relative}[See here for details.]


= FAQ

link:docs/FAQ{ext-relative}[See here for details.]
